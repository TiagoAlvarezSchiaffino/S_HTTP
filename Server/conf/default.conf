server {
	listen          8080 8081 8082;
	# server_name     localhost;
	root			htdocs;
	# root			html;
	index			index.html;
	
	cgi_script		.bla .wow /cgi-bin/cgi1;
	cgi_script		.ok .not /cgi-bin/cgi2;
	
	location / {
		limit_except	GET;
	}
	
	location /put_test {
		upload		htdocs anotherOne;
	}
	
	location /post_body {
		client_max_body_size    100;
	}
	
	location /directory {
		root		htdocs;
		index		htdocs.bad_extension;
	}
}

# We need a map to store <extsion, pathToCgi>
# std::string	checkCgi()
# A function to check whether the path needs to be called to its cgi -> return path, else return ""

# Eulee
# A function to print out HTTP to socket, also need to print out status code into the terminal (Magenta)
# 	-> int	sendHttp(int statusCode, std::string path = "")
# 	-> std::cout << MAGENTA << "Closed with status code: " << statusCode << RESET << std::endl;
# 	-> return (statusCode);
# 	statusCode = 200, 404, 405
# 	statusMessage = OK, Not Found, Not Allowed
# 	"HTTP/1.1 {statusCode} {statusCodeMessage}\r\n\r\n"
# 	Check if string.size() == 0 -> Use our default page as filePath;
#  	Else -> Check whether the html file exists or not
# 	If it doesn't exist, then statusCode becomes 404;	
# 	path = defaultErrorPage
# 	Else -> Extract html from file
# 	Apped the content in the .html file to the header -> output = header + html;
# 	std::cout << MAGENTA << "Closed with status code: " << statusCode << RESET << std::endl;
# 	ft_select(this->_database.socket, (void *)output.c_str(), output.length(), WRITE)
# 	close(this->_database.socket);
# 	return (statusCode);
#
# So if index is not specified in the location block, it will search for the index in server block in that file system directory and serve it
#
#
#
#
#
# void	WebServer::_convertLocation() // Util
# {
# 	if (this->_database.methodPath == "/" || this->_database.method != "GET")
# 		return ;

# 	// size_t	firstSlashPos = this->_database.methodPath.find("/", 1);
# 	std::string	locationToFind = this->_database.methodPath;
# 	// if (firstSlashPos != std::string::npos)
# 		// locationToFind = "/" + this->_database.methodPath.substr(1, firstSlashPos - 1);

# 	std::cout << "Location to find: " << locationToFind << std::endl;
# 	EuleePocket	myServer = this->_database.server[this->_database.serverIndex];
# 	if (myServer.location.find(locationToFind) == myServer.location.end())
# 	{
# 		if (this->_database.methodPath[this->_database.methodPath.length() - 1] == '/')
# 			this->_database.methodPath.erase(this->_database.methodPath.length() - 1);

		
# 		return ;
# 	}

# 	if (myServer.location[locationToFind][ROOT].size() != 0)
# 	{
# 		std::string root = myServer.location[locationToFind][ROOT][0];
# 		std::string newPath = root + this->_database.methodPath.substr(this->_database.methodPath.find(root) + root.length());
# 		this->_database.methodPath = "/" + root + this->_database.methodPath.substr(this->_database.methodPath.find(root) + root.length());
# 	}
	
# 	std::cout << this->_database.checkPath(this->_database.methodPath, 1, 0) << std::endl;
# 	if (this->_database.checkPath(this->_database.methodPath.c_str() + 1, 1, 0))
# 		return ;
# 	// std::cout << "NormalFile = " << this->_database.methodPath << std::endl;
# 	// std::ifstream	normalFile((this->_database.methodPath + "/").c_str() + 1);
# 	// if (normalFile.good())
# 	// 	return ;

# 	std::string	indexToFind = myServer[INDEX][0];
# 	std::string	methodPathCopy = "";
# 	int			found = 0;
# 	std::cout << "Size: " << myServer.location[locationToFind][INDEX].size() << std::endl;
# 	for (size_t	i = 0; i < myServer.location[locationToFind][INDEX].size() && found == 0; i++)
# 	{
# 		indexToFind = myServer.location[locationToFind][INDEX][i];
# 		methodPathCopy = this->_database.methodPath;
		
# 		std::cout << "File to check : " << (methodPathCopy + "/" + indexToFind).c_str() + 1 << std::endl;
# 		if (this->_database.checkPath((methodPathCopy + "/" + indexToFind).c_str() + 1, 1, 0))
# 			found = 1;
# 	}

# 	// if (found == 0) // Shit out index.html
# 	// {
# 	// 	for (size_t i = 0; i < myServer[INDEX].size(); i++)
# 	// 	{
# 	// 		indexToFind = myServer[INDEX][i];
# 	// 		methodPathCopy = this->_database.methodPath;

# 	// 		std::ifstream	file((methodPathCopy + "/" + indexToFind).c_str() + 1);
# 	// 		if (file.good())
# 	// 			break ;
# 	// 	}
# 	// }
# 	if (found == 0)
# 	{
# 		if (this->_database.methodPath[this->_database.methodPath.length() - 1] == '/')
# 			this->_database.methodPath.erase(this->_database.methodPath.length() - 1);
# 		size_t	lastSlashPos = this->_database.methodPath.find_last_of('/');
# 		std::string	newPath = this->_database.methodPath.substr(0, lastSlashPos);
# 		// this->_database.method = 
# 		std::cout << "NewPath: " << newPath << std::endl;
# 		this->_database.methodPath = newPath;
# 		this->_convertLocation();
# 		std::cout << "AfterConvert:: " << this->_database.methodPath << std::endl;
# 		return ;
# 	}
# 	this->_database.methodPath = methodPathCopy + "/" + indexToFind;
# 	std::cout << GREEN << "New path: " << this->_database.methodPath << RESET << std::endl;
# }